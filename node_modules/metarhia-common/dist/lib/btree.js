'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _marked =
/*#__PURE__*/
regeneratorRuntime.mark(inorderTraversal);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_DEGREE = 6; // min degree of b-tree.
// All vertices except the root have [degree ... 2 * degree] child nodes
// And [degree - 1 ... 2 * degree - 1] + 1 "empty" elements

var Element = function Element(key, data) {
  var child = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  _classCallCheck(this, Element);

  this.key = key;
  this.data = data;
  this.child = child;
};

var empty = function empty(child) {
  return new Element(undefined, undefined, child);
};

var splitNode = function splitNode(parent, index) {
  var node = parent[index].child;
  var len = node.length;
  var newLeftNode = node.splice(0, len / 2 - 1); // First half

  var mid = node.shift();
  newLeftNode.push(empty(mid.child));
  mid.child = newLeftNode;
  parent.splice(index, 0, mid);
  return parent;
};

var isLeaf = function isLeaf(node) {
  return !node[0].child;
};

var binarySearch = function binarySearch(node, key) {
  var start = 0;
  var end = node.length - 1;

  while (start <= end) {
    var i = start + end >> 1;
    var itemKey = node[i].key;
    if (key > itemKey) start = i + 1;else if (itemKey === undefined || key < itemKey) end = i - 1;else return [true, i];
  }

  return [false, start];
};

function inorderTraversal(start, finish, currNode) {
  var startIndex, finishIndex, currIndex, _currIndex, currElement;

  return regeneratorRuntime.wrap(function inorderTraversal$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          startIndex = start === undefined ? 0 : binarySearch(currNode, start)[1];
          finishIndex = finish === undefined ? currNode.length - 1 : binarySearch(currNode, finish)[1];

          if (!isLeaf(currNode)) {
            _context.next = 12;
            break;
          }

          currIndex = startIndex;

        case 4:
          if (!(currIndex < finishIndex)) {
            _context.next = 10;
            break;
          }

          _context.next = 7;
          return currNode[currIndex].data;

        case 7:
          currIndex++;
          _context.next = 4;
          break;

        case 10:
          _context.next = 22;
          break;

        case 12:
          _currIndex = startIndex;

        case 13:
          if (!(_currIndex < finishIndex)) {
            _context.next = 21;
            break;
          }

          currElement = currNode[_currIndex];
          return _context.delegateYield(inorderTraversal(start, finish, currElement.child), "t0", 16);

        case 16:
          _context.next = 18;
          return currElement.data;

        case 18:
          _currIndex++;
          _context.next = 13;
          break;

        case 21:
          return _context.delegateYield(inorderTraversal(start, finish, currNode[finishIndex].child), "t1", 22);

        case 22:
        case "end":
          return _context.stop();
      }
    }
  }, _marked, this);
}

var joinNodes = function joinNodes(parent, firstNodeIndex, secondNodeIndex) {
  var firstNode = parent[firstNodeIndex].child;
  var secondNode = parent[secondNodeIndex].child;
  var mid = parent.splice(firstNodeIndex, 1)[0];
  mid.child = firstNode.pop().child;
  secondNode.splice.apply(secondNode, [0, 0].concat(_toConsumableArray(firstNode), [mid]));
  return secondNode;
};

var growChild = function growChild(parent, childIndex) {
  var parentElement = parent[childIndex];
  var node = parentElement.child;
  var minDegree = node.length;

  if (childIndex > 0) {
    // If we have left neighbor
    var leftNeighbor = parent[childIndex - 1].child;

    if (leftNeighbor.length > minDegree) {
      var extractedElement = leftNeighbor.splice(leftNeighbor.length - 2, 1)[0];
      var insertedElement = new Element(parent[childIndex - 1].key, parent[childIndex - 1].data, leftNeighbor[leftNeighbor.length - 1].child);
      leftNeighbor[leftNeighbor.length - 1].child = extractedElement.child;
      extractedElement.child = leftNeighbor;
      parent.splice(childIndex - 1, 1, extractedElement);
      node.unshift(insertedElement);
      return node;
    }
  }

  if (childIndex < parent.length - 1) {
    // If we have right neighbor
    // parent.length - 1 means that we now on the rightmost element
    var rightNeighbor = parent[childIndex + 1].child;

    if (rightNeighbor.length > minDegree) {
      var _extractedElement = rightNeighbor.shift();

      var _insertedElement = new Element(parentElement.key, parentElement.data, node[node.length - 1].child);

      node[node.length - 1].child = _extractedElement.child;
      _extractedElement.child = node;
      parent.splice(childIndex, 1, _extractedElement);
      node.splice(node.length - 1, 0, _insertedElement);
      return node;
    }

    return joinNodes(parent, childIndex, childIndex + 1);
  }

  return joinNodes(parent, childIndex - 1, childIndex);
}; // Get the minimal upper, or the maximum lover node for some given node
//   node - some given node
//   minDegree - value of bTree.minDegree for tree
//   upper - boolean: true - upperLimit, false - lowerLimit
// Result: upperLimit or lowerLimit node


var extractLimit = function extractLimit(node, minDegree, upper) {
  var currNode = node;

  while (!isLeaf(currNode)) {
    var _index = upper ? 0 : currNode.length - 1;

    var nextNode = currNode[_index].child;

    if (nextNode.length === minDegree) {
      nextNode = growChild(currNode, _index);
    }

    currNode = nextNode;
  }

  var index = upper ? 0 : currNode.length - 2;
  return currNode.splice(index, 1)[0];
};

var deleteElement = function deleteElement(node, elementIndex, minDegree) {
  var element = node[elementIndex];
  var deletedData = element.data;
  var leftChild = element.child;
  var rightChild = node[elementIndex + 1].child;

  if (isLeaf(node)) {
    return node.splice(elementIndex, 1)[0].data;
  }

  if (leftChild.length > minDegree) {
    var lowerLimit = extractLimit(leftChild, minDegree, false);
    element.key = lowerLimit.key;
    element.data = lowerLimit.data;
  } else if (rightChild.length > minDegree) {
    var upperLimit = extractLimit(rightChild, minDegree, true);
    element.key = upperLimit.key;
    element.data = upperLimit.data;
  } else {
    joinNodes(node, elementIndex, elementIndex + 1);
    rightChild.splice(minDegree - 1, 1);
  }

  return deletedData;
};

var BTree =
/*#__PURE__*/
function () {
  function BTree() {
    var degree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_DEGREE;

    _classCallCheck(this, BTree);

    this.root = [empty()];
    this.minDegree = degree;
  }

  _createClass(BTree, [{
    key: "get",
    value: function get(key) {
      var currNode = this.root;

      while (currNode) {
        var _binarySearch = binarySearch(currNode, key),
            _binarySearch2 = _slicedToArray(_binarySearch, 2),
            found = _binarySearch2[0],
            i = _binarySearch2[1];

        if (found) {
          return currNode[i].data;
        }

        currNode = currNode[i].child;
      }

      return undefined;
    }
  }, {
    key: "set",
    value: function set(key, data) {
      var newElement = new Element(key, data);

      if (this.root.length === 1) {
        this.root.unshift(newElement);
        return this;
      }

      if (this.root.length === this.minDegree * 2) {
        this.root = [empty(this.root)];
        splitNode(this.root, 0);
      }

      var currNode = this.root;

      while (true) {
        var _binarySearch3 = binarySearch(currNode, key),
            _binarySearch4 = _slicedToArray(_binarySearch3, 2),
            found = _binarySearch4[0],
            nextNodeIndex = _binarySearch4[1];

        if (found) {
          currNode[nextNodeIndex].data = data;
          return this;
        }

        if (isLeaf(currNode)) {
          currNode.splice(nextNodeIndex, 0, newElement);
          return this;
        }

        var nextNode = currNode[nextNodeIndex].child;

        if (nextNode.length === this.minDegree * 2) {
          splitNode(currNode, nextNodeIndex);
          var element = currNode[nextNodeIndex];

          if (element.key === key) {
            element.data = data;
            return this;
          }

          if (element.key > key) {
            nextNode = element.child;
          }
        }

        currNode = nextNode;
      }
    }
  }, {
    key: "iterator",
    value: function iterator(start, finish) {
      return inorderTraversal(start, finish, this.root);
    }
  }, {
    key: "remove",
    value: function remove(key) {
      var currNode = this.root;

      while (currNode) {
        var _binarySearch5 = binarySearch(currNode, key),
            _binarySearch6 = _slicedToArray(_binarySearch5, 2),
            found = _binarySearch6[0],
            index = _binarySearch6[1];

        if (found) {
          var deletedData = deleteElement(currNode, index, this.minDegree);

          if (this.root.length === 1 && this.root[0].child) {
            this.root = this.root[0].child;
          }

          return deletedData;
        } else {
          var nextNode = currNode[index].child;

          if (nextNode && nextNode.length === this.minDegree) {
            nextNode = growChild(currNode, index);
          }

          currNode = nextNode;
        }
      }

      if (this.root.length === 1 && this.root[0].child) {
        this.root = this.root[0].child;
      }

      return undefined;
    }
  }]);

  return BTree;
}();

module.exports = {
  BTree: BTree
};