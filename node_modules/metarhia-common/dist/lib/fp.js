'use strict';

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var _require = require('./callbacks'),
    safeCallback = _require.safeCallback; // Partially apply arguments to function
//   fn - <Function>
//   args - <Array>, arguments to be applied
// Returns: <Function>
//   rest - <Array>, arguments


var partial = function partial(fn) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, rest = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      rest[_key2] = arguments[_key2];
    }

    return fn.apply(void 0, _toConsumableArray(args.concat(rest)));
  };
}; // Map object fields with provided function
//   mapFn - <Function>, to apply to every field value
//   obj - <Object>, which fields used for mapping
// Returns: <Object>, with same reference but with transformed fields


var omap = function omap(mapFn, obj) {
  for (var key in obj) {
    obj[key] = mapFn(obj[key]);
  }

  return obj;
}; // Compose multiple functions into one
//   fns - <Array>, functions to be composed
// Returns: <Function>, composed
//   args - <Array>, arguments to be passed to the first function


var compose = function compose() {
  for (var _len3 = arguments.length, fns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    fns[_key3] = arguments[_key3];
  }

  return function () {
    if (fns.length === 0) return arguments.length <= 0 ? undefined : arguments[0];
    var res = fns[0].apply(fns, arguments);

    for (var i = 1; i < fns.length; i++) {
      res = fns[i](res);
    }

    return res;
  };
}; // Apply given function to value or default value
//   fn - <Function>
//   defVal - <any>, default value
//   value - <any>, value (optional)
// Returns: <any>, result of `fn` or `defVal`


var maybe = function maybe(fn, defVal, value) {
  return value !== undefined && value !== null ? fn(value) : defVal;
}; // Zip several arrays into one
//   arrays - <Array[]>, arrays to be zipped
// Returns: <Array>, length is minimal of input arrays length,
//          element with index i of resulting array is array with
//          elements with index i from input array


var zip = function zip() {
  for (var _len4 = arguments.length, arrays = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    arrays[_key4] = arguments[_key4];
  }

  if (arrays.length === 0) return arrays;
  var minLen = arrays[0].length;

  for (var i = 1; i < arrays.length; i++) {
    minLen = Math.min(arrays[i].length, minLen);
  }

  var res = new Array(minLen);

  for (var _i = 0; _i < res.length; _i++) {
    res[_i] = new Array(arrays.length);

    for (var j = 0; j < res[_i].length; j++) {
      res[_i][j] = arrays[j][_i];
    }
  }

  return res;
}; // Create array of replicated values
//   count - <number>, new array length
//   elem - <any>, value to replicate
// Returns: <Array>, replicated


var replicate = function replicate(count, elem) {
  return Array.from({
    length: count
  }, function () {
    return elem;
  });
}; // Zip arrays using specific function
//   fn - <Function>, for zipping elements with index i
//   arrays - <Array[]>, arrays to be zipped
// Returns: <Array>, zipped, element with index i of resulting array is result
//          of fn called with arguments from arrays


var zipWith = function zipWith(fn) {
  for (var _len5 = arguments.length, arrays = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
    arrays[_key5 - 1] = arguments[_key5];
  }

  return zip.apply(void 0, arrays).map(function (args) {
    return fn.apply(void 0, _toConsumableArray(args));
  });
}; // Curry function until the condition is met
//   condition - <Function>, function(argsI, argsParts) returns boolean
//     argsI - <Array>, arguments for i-th currying
//     argsParts - <Array>, of args given for currying
//                 from first to i-th currying
//   fn - <Function>, to be curried
//   args - <Array>, arguments for fn
// Returns: <Function>, curried
//   args - <Array>, arguments


var curryUntil = function curryUntil(condition, fn) {
  var argsParts = [];

  var curryMore = function curryMore() {
    for (var _len7 = arguments.length, argsI = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      argsI[_key7] = arguments[_key7];
    }

    argsParts.push(argsI);

    if (condition(argsI, argsParts)) {
      var _ref;

      var allArgs = (_ref = []).concat.apply(_ref, argsParts);

      return fn.apply(void 0, _toConsumableArray(allArgs));
    }

    return curryMore;
  };

  for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    args[_key6 - 2] = arguments[_key6];
  }

  return curryMore.apply(void 0, args);
}; // Curry function with given arguments
//   fn - <Function>, to be curried
//   param - <Array>, arguments to the function
// Returns: <Function>, curried


var curry = function curry(fn) {
  var curried = function curried() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }

    return fn.length > args.length ? curry(fn.bind.apply(fn, [null].concat(args))) : fn.apply(void 0, args);
  };

  for (var _len8 = arguments.length, param = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
    param[_key8 - 1] = arguments[_key8];
  }

  return param.length ? curried.apply(void 0, param) : curried;
}; // Curry fn count times, first curry uses args for first currying
//   fn - <Function>, to be curried
//   count - <number>, of times function should be curried
//   args - <Array>, arguments for first currying
// Returns: <Function>, curried given times count


var curryN = function curryN(fn, count) {
  var i = -1;

  var condition = function condition() {
    return i++, i === count;
  };

  for (var _len10 = arguments.length, args = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {
    args[_key10 - 2] = arguments[_key10];
  }

  return curryUntil.apply(void 0, [condition, fn].concat(args));
}; // Curry function curry with fn
//   fn - <Function>, to be curried
// Returns: <Function>, to pass arguments that returns curried fn


var curryTwice = function curryTwice(fn) {
  return curry(curry, fn);
}; // Apply arguments
//   args - <Array>, arguments to save in closure
// Returns: <Function>
//     fn - <Function>, to be applied saved arguments
//   Returns: <any>, result of `fn(...args)`


var applyArgs = function applyArgs() {
  for (var _len11 = arguments.length, args = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
    args[_key11] = arguments[_key11];
  }

  return function (fn) {
    return fn.apply(void 0, args);
  };
}; // Get first not errored result of fn
//   fn - <Function>, to be called
// Returns: <Function>
//     args - <Array>, arguments to iterate
//   Returns: <any>, result of `fn(arg)`,
//            where `arg` - first valid element of `args`
// Throws: <Error>, if `fn` throws it


var either = function either(fn) {
  return function () {
    var lastError;

    for (var _len12 = arguments.length, args = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      args[_key12] = arguments[_key12];
    }

    for (var _i2 = 0; _i2 < args.length; _i2++) {
      var arg = args[_i2];

      try {
        return fn(arg);
      } catch (error) {
        lastError = error;
      }
    }

    throw lastError;
  };
}; // Rest left, transform function
//   fn - <Function>, function(args, ...namedArgs, callback)
//     args - <Array>, rest of spreadArgs created by excluding namedArgs
//     namedArgs - <Array>, first values of spreadArgs,
//                 length is based upon interface of fn
//     callback - <Function>, callback, last argument of spreadArgs
// Returns: <Function>
//   spreadArgs - <Array>, arguments to be added


var restLeft = function restLeft(fn) {
  return function () {
    for (var _len13 = arguments.length, spreadArgs = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
      spreadArgs[_key13] = arguments[_key13];
    }

    var callback = safeCallback(spreadArgs);
    var namedArgsCount = fn.length - 2;
    var namedArgs = spreadArgs.slice(0, namedArgsCount);
    var args = spreadArgs.slice(namedArgsCount);
    fn.apply(void 0, [args].concat(_toConsumableArray(namedArgs), [callback]));
  };
};

module.exports = {
  partial: partial,
  omap: omap,
  compose: compose,
  maybe: maybe,
  zip: zip,
  replicate: replicate,
  zipWith: zipWith,
  curryUntil: curryUntil,
  curryN: curryN,
  curryTwice: curryTwice,
  curry: curry,
  applyArgs: applyArgs,
  either: either,
  restLeft: restLeft
};